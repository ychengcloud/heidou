// Code generated by hedone, DO NOT EDIT.

package models

import (
	"fmt"
	"io"
	"strconv"
	{{- if .HasTimeField }}
	"time"
	{{- end}}
)
{{$tables := .Tables}}
{{range $tables}}
{{- $tableName := .Name}}
{{- $tableNameCamel := .NameCamel}}
type {{.NameCamel}} struct {
	{{- range .Fields}}
	{{- $name := .NameCamel}}
	{{- $type := ""}}
	{{- $associationModel := getModel $tables .TableName}}
		{{- if eq .JoinType "" }}
	{{- $type = .MetaType.GoType }}
		{{- end }}
		{{- if or (eq .JoinType "BelongTo") (eq .JoinType "HasOne") }}
	{{- $name = .NameCamel}}
	{{- $type = $associationModel.NameCamel}}
		{{- end}}
		{{- if or (eq .JoinType "ManyToMany") (eq .JoinType "HasMany") }}
	{{- $name = .NameCamelPlural}}
	{{- $type = (printf "%s%s" "[]*" $associationModel.NameCamel)}}
		{{- end}}
	{{$name}} {{$type}} `{{.TagsHTML}}`
	{{- end}}
}

//TableName
func (m *{{.NameCamel}}) TableName() string {
	return "{{.Name}}"
}

func ({{.NameCamel}}) IsNode()   {}
func ({{.NameCamel}}) IsEntity() {}

type {{.NameCamel}}BulkDelete struct {
	Errors []*{{.NameCamel}}Error `json:"errors"`
	Count  int              `json:"count"`
}

type {{.NameCamel}}Connection struct {
	PageInfo   *PageInfo       `json:"pageInfo"`
	Edges      []*{{.NameCamel}}Edge `json:"edges"`
	TotalCount int             `json:"totalCount"`
}

type {{.NameCamel}}Create struct {
	Errors  []*{{.NameCamel}}Error `json:"errors"`
	{{.NameCamel}} *{{.NameCamel}}        `json:"{{.NameLowerCamelPlural}}"`
}

type {{.NameCamel}}Delete struct {
	Errors  []*{{.NameCamel}}Error `json:"errors"`
	{{.NameCamel}} *{{.NameCamel}}        `json:"{{.NameLowerCamelPlural}}"`
}

type {{.NameCamel}}Edge struct {
	Node   *{{.NameCamel}} `json:"node"`
	Cursor string   `json:"cursor"`
}

type {{.NameCamel}}Error struct {
	Field   string           `json:"field"`
	Message string           `json:"message"`
	Code    {{.NameCamel}}ErrorCode `json:"code"`
}

type {{.NameCamel}}Input struct {
	{{- range .Fields}}
	{{- if not .IsPrimaryKey}}
	{{- $name := .NameCamel}}
	{{- $type := ""}}
	{{- $associationModel := getModel $tables .TableName}}
		{{- if eq .JoinType "" }}
	{{- $type = .MetaType.GoType }}
		{{- end }}
		{{- if or (eq .JoinType "BelongTo") (eq .JoinType "HasOne") }}
	{{- $name = .NameCamel}}
	{{- $type = (printf "*%sInput" $associationModel.NameCamel)}}
		{{- end}}
		{{- if or (eq .JoinType "ManyToMany") (eq .JoinType "HasMany") }}
	{{- $name = .NameCamelPlural}}
	{{- $type = (printf "%s%sInput" "[]*" $associationModel.NameCamel)}}
		{{- end}}
	{{$name}} {{$type}} `{{.TagsHTML}}`
	{{- end}}
	{{- end}}
}

{{- if .Filterable}}
type {{.NameCamel}}FilterInput struct {
	{{- range .Fields}}
	{{- if .IsFilterable}}
	{{.NameCamel}} []*{{$tableNameCamel}}Op{{.NameCamel}}Input
	{{- end}}
	{{- end}}
	AND *{{$tableNameCamel}}FilterInput
  	OR *{{$tableNameCamel}}FilterInput
  	NOT *{{$tableNameCamel}}FilterInput
}
{{- range .Fields}}
{{- if .IsFilterable}}
type {{$tableNameCamel}}Op{{.NameCamel}}Input struct {
  {{- $t := (printf "*%s" .MetaType.GoType)}}
  {{- range .Operations}}
  {{- if eq . "In"}}
  {{- $t = (printf "[]%s" $t)}}
  {{- end}}
  {{.}} {{$t}}
  {{- end}}
}
{{- end}}
{{- end}}
{{- end}}

func (i *{{.NameCamel}}Input) ToORM() *{{.NameCamel}} {
	{{.NameLowerCamel}} := &{{.NameCamel}}{
		{{- range .Fields}}
		{{- if eq .JoinType ""}}
		{{- if not .IsPrimaryKey}}
		{{.NameCamel}}: i.{{.NameCamel}},
		{{- end}}
		{{- end}}
		{{- end}}
	}

	{{- $nameLowerCamelInput := .NameLowerCamel}}
	{{- range .Fields}}
	{{- if or (eq .JoinType "HasMany") (eq .JoinType "ManyToMany") }}
	if i.{{.NameCamelPlural}} != nil {
		{{- $associationModel := getModel $tables .TableName}}

		{{.NameLowerCamelPlural}} := make([]*{{$associationModel.NameCamel}}, 0, len(i.{{.NameCamelPlural}}))
		for _, {{.NameLowerCamel}} := range i.{{.NameCamelPlural}} {
			{{.NameLowerCamelPlural}} = append({{.NameLowerCamelPlural}}, {{.NameLowerCamel}}.ToORM())
		}
		{{$nameLowerCamelInput}}.{{.NameCamelPlural}} = {{.NameLowerCamelPlural}}
	}
	{{- end}}
	{{- if or (eq .JoinType "HasOne") (eq .JoinType "BelongTo") }}
	if i.{{.NameCamel}} != nil {
		{{$nameLowerCamelInput}}.{{.NameCamel}} = i.{{.NameCamel}}.ToORM()
	}
	{{- end}}
	{{- end}}
	
	return {{.NameLowerCamel}}
}

type {{.NameCamel}}SortingInput struct {
	Direction OrderDirection   `json:"direction"`
	Field     {{.NameCamel}}SortField `json:"field"`
}

type {{.NameCamel}}Update struct {
	Errors  []*{{.NameCamel}}Error `json:"errors"`
	{{.NameCamel}} *{{.NameCamel}}        `json:"{{.NameLowerCamelPlural}}"`
}

type {{.NameCamel}}UpdateMeta struct {
	Errors  []*{{.NameCamel}}Error `json:"errors"`
	{{.NameCamel}} *{{.NameCamel}}        `json:"{{.NameLowerCamelPlural}}"`
}

type {{.NameCamel}}UpdatePrivateMeta struct {
	Errors  []*{{.NameCamel}}Error `json:"errors"`
	{{.NameCamel}} *{{.NameCamel}}        `json:"{{.NameLowerCamelPlural}}"`
}

type {{.NameCamel}}ErrorCode string

const (
	{{$tableNameCamel}}ErrorCodeInvalid	{{$tableNameCamel}}ErrorCode = "Invalid"

	{{$tableNameCamel}}ErrorCodeNotFound	{{$tableNameCamel}}ErrorCode = "NotFound"
	
	{{$tableNameCamel}}ErrorCodeAlreadyExists	{{$tableNameCamel}}ErrorCode = "AlreadyExists"
	
	{{range .ErrorCodes}}
	{{$tableNameCamel}}ErrorCode{{.}}	{{$tableNameCamel}}ErrorCode = "{{.}}"
	{{end}}
)

var All{{.NameCamel}}ErrorCode = []{{.NameCamel}}ErrorCode{
	{{$tableNameCamel}}ErrorCodeInvalid,
	{{$tableNameCamel}}ErrorCodeNotFound,
	{{$tableNameCamel}}ErrorCodeAlreadyExists,
	{{- range .ErrorCodes}}
	{{$tableNameCamel}}ErrorCode{{.}},
	{{- end}}
}

func (e {{.NameCamel}}ErrorCode) IsValid() bool {
	switch e {
	case {{$tableNameCamel}}ErrorCodeInvalid, {{$tableNameCamel}}ErrorCodeNotFound, {{$tableNameCamel}}ErrorCodeAlreadyExists:
		return true
	{{range .ErrorCodes}}
	case {{$tableNameCamel}}ErrorCode{{.}}:
		return true
 	{{end}}
	}
	return false
}

func (e {{.NameCamel}}ErrorCode) String() string {
	return string(e)
}

func (e *{{.NameCamel}}ErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = {{.NameCamel}}ErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid {{.NameCamel}}ErrorCode", str)
	}
	return nil
}

func (e {{.NameCamel}}ErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type {{.NameCamel}}SortField string
{{if .Sortable}}
const (
	{{- range .Fields}}
	{{- if .IsSortable}}
	{{$tableName}}SortField{{.NameCamel}}             {{$tableName}}SortField = "{{.NameCamel}}"
	{{- end}}
	{{- end}}
)

var All{{.NameCamel}}SortField = []{{.NameCamel}}SortField{
	{{- range .Fields}}
	{{- if .IsSortable}}
	{{$tableName}}SortField{{.NameCamel}},
	{{- end}}
	{{- end}}
}

func (e {{.NameCamel}}SortField) IsValid() bool {
	switch e {
	{{- range .Fields}}
	{{- if .IsSortable}}
	case {{$tableName}}SortField{{.NameCamel}}:
		return true
	{{- end}}
	{{- end}}
	}
	return false
}

func (e {{.NameCamel}}SortField) String() string {
	return string(e)
}

func (e *{{.NameCamel}}SortField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = {{.NameCamel}}SortField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid {{.NameCamel}}SortField", str)
	}
	return nil
}

func (e {{.NameCamel}}SortField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
{{end}}
{{end}}