package repositories

import (
	"fmt"
	"strings"

	"github.com/go-openapi/inflect"
	"github.com/google/wire"
	"gorm.io/gorm"

	"{{.PkgPath}}/internal/gen/models"
)

const (
	OpEq    = "eq"
	OpIn    = "in"
	OpNot   = "not"
	OpNotIn = "notin"
	OpGt    = "gt"
	OpGte   = "gte"
	OpLt    = "lt"
	OpLte   = "lte"
	OpLike  = "like"
)

const (
	MaxLimitCount = 1000
)

var (
	rules    = ruleset()
	acronyms = make(map[string]struct{})
)

var BaseProviderSet = wire.NewSet(
    {{- range .Tables}}
    NewGorm{{.NameCamel}}Repository,
    {{- end}}
)

//result 返回为空串，表示不符合任何支持的操作符
func operation(op string) (result string) {
	switch strings.ToLower(op) {
	case OpEq:
		result = "= ?"
	case OpNot:
		result = "!= ?"
	case OpGt:
		result = "> ?"
	case OpGte:
		result = ">= ?"
	case OpLt:
		result = "< ?"
	case OpLte:
		result = "<= ?"
	case OpLike:
		result = "LIKE ?"
	case OpIn:
		result = "IN (?)"
	case OpNotIn:
		result = "NOT IN (?)"
	}
	return
}

func isSeparator(r rune) bool {
	return r == '_' || r == '-'
}

func pascalWords(words []string) string {
	for i, w := range words {
		upper := strings.ToUpper(w)
		if _, ok := acronyms[upper]; ok {
			words[i] = upper
		} else {
			words[i] = rules.Capitalize(w)
		}
	}
	return strings.Join(words, "")
}

// pascal converts the given name into a PascalCase.
//
//	user_info 	=> UserInfo
//	full_name 	=> FullName
//	user_id   	=> UserID
//	full-admin	=> FullAdmin
//
func pascal(s string) string {
	words := strings.FieldsFunc(s, isSeparator)
	return pascalWords(words)
}

func ruleset() *inflect.Ruleset {
	rules := inflect.NewDefaultRuleset()
	// Add common initialisms from golint and more.
	for _, w := range []string{
		"ACL", "API", "ASCII", "AWS", "CPU", "CSS", "DNS", "EOF", "GB", "GUID",
		"HTML", "HTTP", "HTTPS", "ID", "IP", "JSON", "KB", "LHS", "MAC", "MB",
		"QPS", "RAM", "RHS", "RPC", "SLA", "SMTP", "SQL", "SSH", "SSO", "TCP",
		"TLS", "TTL", "UDP", "UI", "UID", "URI", "URL", "UTF8", "UUID", "VM",
		"XML", "XMPP", "XSRF", "XSS",
	} {
		acronyms[w] = struct{}{}
		rules.AddAcronym(w)
	}
	return rules
}

func Query(db *gorm.DB, q *models.Query) *gorm.DB {
	for _, filter := range q.Filter {
		w := strings.SplitN(filter, ":", 3)
		// 不满足条件三元组的格式, eg: id:eq:1
		if len(w) != 3 {
			continue
		}

		name, op, value := w[0], w[1], w[2]
		result := operation(op)
		if len(result) == 0 {
			continue
		}
		field := fmt.Sprintf("`%s` %s", name, result)
		lowerOp := strings.ToLower(op)

		if lowerOp == OpIn || lowerOp == OpNotIn {
			args := strings.Split(value, ",")
			fmt.Println("args:", value, len(args))
			db = db.Where(field, args)
			continue
		}

		args := value
		if lowerOp == OpLike {
			args = fmt.Sprintf("%%%s%%", value)
		}
		db = db.Where(field, args)

	}

	if q.Order != "" {
		db = db.Order(q.Order)
	}
	if q.Offset > 0 {
		db = db.Offset(q.Offset)
	}
	if q.Limit > MaxLimitCount {
		q.Limit = MaxLimitCount
	}
	if q.Limit > 0 {
		db = db.Limit(q.Limit)

	}
	return db
}

func Select(db *gorm.DB, fields string) *gorm.DB {
	if fields == "" {
		return db
	}
	columns := strings.Split(fields, ",")
	if len(columns) > 0 {
		db = db.Select(columns)
	}
	return db
}
func Expands(db *gorm.DB, expands string) *gorm.DB {
	if len(expands) == 0 {
		return db
	}

	expandsList := strings.Split(expands, ",")
	for _, expand := range expandsList {
		expandNameList := strings.Split(expand, ".")
		var preloadList []string
		for _, expandName := range expandNameList {
			preloadList = append(preloadList, pascal(expandName))
		}
		preload := strings.Join(preloadList, ".")
		db = db.Preload(preload)
	}

	return db
}
