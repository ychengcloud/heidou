package repositories

import (
	"strings"

	"github.com/jinzhu/gorm"
	"github.com/pkg/errors"
	"go.uber.org/zap"

	"{{.AppPkg}}/gen/models"
)

{{- $primaryKeyColumnName := .PrimaryKeyColumnName}}
{{- $primaryKeyLowerColumnName := .PrimaryKeyLowerColumnName}}
{{- $primaryKeyColumnType := .PrimaryKeyColumnType}}
type {{.ModelName}}Repository interface {
	List(q *models.PaginationQuery) (list []*models.{{.ModelName}}, total uint, err error)
	Create({{.HandlerName}} *models.{{.ModelName}}) (err error)
	Get({{$primaryKeyLowerColumnName}} {{$primaryKeyColumnType}}) ({{.HandlerName}} *models.{{.ModelName}}, err error)
	Update({{.HandlerName}} *models.{{.ModelName}}) (err error)
	Delete({{$primaryKeyLowerColumnName}} {{$primaryKeyColumnType}}) (err error)
	BatchGet({{$primaryKeyLowerColumnName}}List []{{$primaryKeyColumnType}}) ([]*models.{{.ModelName}}, error)
	BatchDelete({{$primaryKeyLowerColumnName}}List []{{$primaryKeyColumnType}}) (err error)
}

type Gorm{{.ModelName}}Repository struct {
	logger *zap.Logger
	db     *gorm.DB
}

func NewGorm{{.ModelName}}Repository(logger *zap.Logger, db *gorm.DB) {{.ModelName}}Repository {
	return &Gorm{{.ModelName}}Repository{
		logger: logger.With(zap.String("type", "{{.ModelName}}Repository")),
		db:     db,
	}
}

//List ...
func (s *Gorm{{.ModelName}}Repository) List(q *models.PaginationQuery) (list []*models.{{.ModelName}}, total uint, err error) {
	{{.ModelName}} := &models.{{.ModelName}}{}

	var db *gorm.DB
	total, db = GetResourceCount(s.db, {{.ModelName}}, q)
	if q.Fields != "" {
		columns := strings.Split(q.Fields, ",")
		if len(columns) > 0 {
			db = db.Select(q.Fields)
		}
	}
	if q.Order != "" {
		db = db.Order(q.Order)
	}
	if q.Offset > 0 {
		db = db.Offset(q.Offset)
	}
	if q.Limit > 1000 {
		q.Limit = 1000
	}
	if q.Limit > 0 {
		db = db.Limit(q.Limit)

	}

	list = make([]*models.{{.ModelName}}, 0)
	err = db.Find(&list).Error
	return list, total, err
}

func (s *Gorm{{.ModelName}}Repository) Create({{.HandlerName}} *models.{{.ModelName}}) (err error) {
	tx := s.db.Begin()
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	err = tx.Create({{.HandlerName}}).Error
	if err != nil {
		return
	}

	{{- $handlerName := .HandlerName}}
	{{- range .Properties}}
    {{- if .IsAssociation }}
	{{- if eq .ModelType "m2m"}}
    {{.ModelPropLowerCamelPlural}} := make([]*models.{{.ModelPropCamel}}, 0, len({{$handlerName}}.{{.ModelAliasCamelPlural}}))
	for _, m := range {{$handlerName}}.{{.ModelAliasCamelPlural}} {
		{{.ModelPropLowerCamel}} := &models.{{.ModelPropCamel}}{}
		err = tx.Where(&m).First({{.ModelPropLowerCamel}}).Error
		if err != nil {
			tx.Rollback()
			return err
		}
		if err = tx.Model({{$handlerName}}).Association("{{.ModelPropCamelPlural}}").Append({{.ModelPropLowerCamel}}).Error; err != nil {
			tx.Rollback()
			return err
		}
		{{.ModelPropLowerCamelPlural}} = append({{.ModelPropLowerCamelPlural}}, {{.ModelPropLowerCamel}})
	}
	{{$handlerName}}.{{.ModelAliasCamelPlural}} = {{.ModelPropLowerCamelPlural}}
	{{- end}}
    {{- end}}
    {{- end}}

	tx.Commit()
	return
}

func (s *Gorm{{.ModelName}}Repository) Get({{$primaryKeyLowerColumnName}} {{$primaryKeyColumnType}}) ({{.HandlerName}} *models.{{.ModelName}}, err error) {
	{{.HandlerName}} = &models.{{.ModelName}}{}

    db := s.db.Model({{.HandlerName}})
    {{- range .Properties}}
    {{- if .IsAssociation }}
    db = db.Preload("{{.ModelAliasCamelPlural}}")
    {{- end}}
    {{- end}}
	if err = db.Where("{{$primaryKeyLowerColumnName}} = ?", {{$primaryKeyLowerColumnName}}).First({{.HandlerName}}).Error; err != nil {
		return nil, errors.Wrapf(err, "get {{.ModelName}} error[id=%d]", {{$primaryKeyLowerColumnName}})
	}
	return
}

func (s *Gorm{{.ModelName}}Repository) Update({{.HandlerName}} *models.{{.ModelName}}) (err error) {
	tx := s.db.Begin()
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	err = tx.Model({{.HandlerName}}).Update({{.HandlerName}}).Error
	if err != nil {
		return
	}

	{{- $handlerName := .HandlerName}}
	{{- range .Properties}}
    {{- if .IsAssociation }}
	{{- if eq .ModelType "m2m"}}
    {{.ModelPropLowerCamelPlural}} := make([]*models.{{.ModelPropCamel}}, 0, len({{$handlerName}}.{{.ModelAliasCamelPlural}}))
	for _, m := range {{$handlerName}}.{{.ModelAliasCamelPlural}} {
		{{.ModelPropLowerCamel}} := &models.{{.ModelPropCamel}}{}
		err = tx.Where(&m).First({{.ModelPropLowerCamel}}).Error
		if err != nil {
			tx.Rollback()
			return err
		}
		if err = tx.Model({{$handlerName}}).Association("{{.ModelPropCamelPlural}}").Replace({{.ModelPropLowerCamel}}).Error; err != nil {
			tx.Rollback()
			return err
		}
		{{.ModelPropLowerCamelPlural}} = append({{.ModelPropLowerCamelPlural}}, {{.ModelPropLowerCamel}})
	}
	{{$handlerName}}.{{.ModelAliasCamelPlural}} = {{.ModelPropLowerCamelPlural}}
	{{- end}}
    {{- end}}
    {{- end}}

	tx.Commit()
	return
}

func (s *Gorm{{.ModelName}}Repository) Delete({{$primaryKeyLowerColumnName}} {{$primaryKeyColumnType}}) (err error) {
	tx := s.db.Begin()
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	if {{$primaryKeyLowerColumnName}} == 0 {
		return models.ErrBadParamInput
	}

	{{.HandlerName}} := &models.{{.ModelName}}{ {{$primaryKeyColumnName}}: {{$primaryKeyLowerColumnName}} }
	if err = tx.Delete({{.HandlerName}}).Error; err != nil {
		return errors.Wrapf(err, "delete {{.ModelName}} error[id=%d]", {{$primaryKeyLowerColumnName}})
	}

	tx.Commit()
	return
}

func (s *Gorm{{.ModelName}}Repository) BatchGet({{$primaryKeyLowerColumnName}}List []{{$primaryKeyColumnType}}) (list []*models.{{.ModelName}}, err error) {
	list = make([]*models.{{.ModelName}}, 0, len({{$primaryKeyLowerColumnName}}List))

	db := s.db.Model(&models.{{.ModelName}}{})
	if err = db.Where("id IN (?)", {{$primaryKeyLowerColumnName}}List).Find(&list).Error; err != nil {
		return nil, errors.Wrapf(err, "get {{.ModelName}} error[id=%d]", len({{$primaryKeyLowerColumnName}}List))
	}
	return
}

func (s *Gorm{{.ModelName}}Repository) BatchDelete({{$primaryKeyLowerColumnName}}List []{{$primaryKeyColumnType}}) (err error) {
	tx := s.db.Begin()
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	for _, {{$primaryKeyLowerColumnName}} := range {{$primaryKeyLowerColumnName}}List {
		if {{$primaryKeyLowerColumnName}} == 0 {
			return models.ErrBadParamInput
		}
	}

	if err = tx.Where("id IN (?)", {{$primaryKeyLowerColumnName}}List).Delete(&models.{{.ModelName}}{}).Error; err != nil {
		return errors.Wrapf(err, "batch delete {{.ModelName}} error[len=%d]", len({{$primaryKeyLowerColumnName}}List))
	}
	tx.Commit()
	return
}
